### 线程

> 创建线程的三种方式
1. extends Thread
2. implements Runable
3. implements Callable

> start()和run()的区别

start()方法属于Thread类，通过sync来同步，里面调用native方法来实现来启动一个线程。
run()方法属于Runnable，数以一个普通方法

> yield()和sleep()的区别

1. yield()，sleep()都能暂停当前线程，sleep可以指定休眠时间，yield则依赖cpu的时间片划分
2. 如果持有锁，都不会释放锁资源
3. yield不能被中断，sleep则可以接受中断

> 多线程的好处

发挥多核CPU的优势，防止阻塞

> Runnable和Callable接口的区别

Runnable接口的void没有返回值，Callable的call有返回值，是一个泛型，和Future和FutureTask配合使用可以得到异步执行的结果。

> Java中如何获取线程dump文件

死循环，死锁，阻塞，页面打开慢等问题，查看线程dump是最好的解决办法，所有线程dump也就是线程堆栈。
1. 获取线程的pid，可以通过使用jps.exe命令，在linux环境下还可以使用ps -ef|grep java
2. 打印线程堆栈，可以通过使用jstack.exe pid命令，在linux环境下还可以通过kill -3 pid

> 线程运行时异常会怎么样

如果没有捕获，线程会停止运行，如果这个线程持有某个对象的monitor，那么这个对象监控器会被立即释放。
如果捕获，现在继续执行。

> 两个线程直接如何共享数据

通过线程之间共享对象就可以了。比如BlockingQueue就是为了线程之间共享数据而设计的。

> ThreadLocal有什么用

ThreadLocal就是一种空间换时间的做法，在没有Thread里面维护了一个以开放地址法实现的ThreadLocal.ThreadLocalMap，将数据进行隔离，数据不共享。

> 为什么wait()，notify()/notifyAll()方法要在同步代码块中被调用

这是JDK强制要求的，这些方法调用前要必须先获得对象的锁。

> 为什么wait()，notify()/notifyAll()方法在放弃对象监控器时有什么区别

wait()会立刻释放对象监控器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会释放对象监控器。

> 为什么要用线程池

避免频繁的创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据实际情况灵活的控制并发数。

> 如何判断一个对象是否持有对象监控器

Thread类提供了一个holdLock(Object obj)方法，仅当对象obj被当前线程持有时才会返回true

> 如何唤醒一个阻塞中的线程

WakeUpBlockingThreadTest.java

如果线程因为调用wait(),sleep(),jon()方法阻塞时,可以根据线程名称进行中断,并通过抛出InterruptException进行唤醒.
如果线程因为IO阻塞,无能为力,因为IO时操作系统实现的,JAVA代码没有办法直接接触操作系统.

> 不可以对象对多线程有什么帮助

不可以对象可以保证对象的可见性,对不可变对象的读取不需要同步,可以提升代码执行效率.

> 线程的上下文切换

是指CPU控制权由一个正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程.

> 如果提交任务时,线程池已满,这时会发生什么.

1. 如果使用的是无界队列,继续添加任务到阻塞队列中
2. 如果有界队列,任务会先添加到有界队列中,如果有界队列也满了,会根据maxPoolSize的值增加线程数量,如果增加了线程数量还是处理不过来,有界队列还是满,这个使用就会使用拒绝策略处理满的任务.

> JAVA 中的线程调度算法

抢占式,一个线程用完CPU之后,操作系统会根据线程优先级,线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个进程

> Thread.sleep(0)的作用是什么

由于Java中的线程调度是抢占式,可能会出现某个线程常常获取CPU控制权的情况,为了让某些优先级比较低的线程也能获取到CPU控制权,可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作,这也是平衡CPU控制权的一种操作.

> 线程类的构造方法,静态块是被那个线程调用的

线程中的构造方法,静态块是被new这个线程类所在的线程调用的,而run()里面的代码菜是被线程本身调用的.

> 同步方法和同步块,那个是更好的选择

同步块,这意味着同步块之外的代码都是异步执行的,这比同步整个方法更提高代码的效率




